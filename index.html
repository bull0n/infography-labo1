<!DOCTYPE html>
<html lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="utf-8"><link rel="stylesheet" href="css/stylesheet.css">
	<script src="js/commonFunctions.js"></script>
	<script src="js/gl-matrix-min.js"></script>
	<script src="js/webglTools.js"></script>
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;

		uniform float uRadius;
		uniform float uCx;
		uniform float uCy;
		uniform float uWidth;
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		varying vec3 pos;
		varying float vRadius;
		varying float vCx;
		varying float vCy;
		varying float vWidth;

		void main(void){
			pos=aVertexPosition;
			vRadius = uRadius;
			vCx = uCx;
			vCy = uCy;
			vWidth = uWidth;

			gl_Position=uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		}
	</script>

	<script id="shader-fs" type="x-shader/x-fragment">
		#ifdef GL_ES
			precision highp float;
		#endif
		varying vec3 pos;
		varying float vRadius;
		varying float vCx;
		varying float vCy;
		varying float vWidth;

		float line(in float a, in float x, in float b)
		{
			return a * x + b;
		}

		void hexagon1()
		{
			vec2 center = vec2(vCx, vCy);
			float fRaduis = vRadius;
			float HALF_WIDTH = vWidth / 2.0;

			float c = 0.5;
			float slope = 4./3.;
			float height = (sqrt(3.)/2.)*c;

			bool cond1 = pos.y - slope*pos.x < c*slope + HALF_WIDTH &&  pos.y - slope*pos.x > c*slope - HALF_WIDTH /*&& pos.x < -b/2.*/; // f(x) = 4/3x + c -> 60° angle
			bool cond2 = pos.y - slope*pos.x < -c*slope + HALF_WIDTH &&  pos.y - slope*pos.x > -c*slope - HALF_WIDTH; // f(x) = 4/3x - c
			bool cond3 = pos.y + slope*pos.x < c*slope + HALF_WIDTH &&  pos.y + slope*pos.x > c*slope - HALF_WIDTH; // f(x) = -4/3x + c
			bool cond4 = pos.y + slope*pos.x < -c*slope + HALF_WIDTH &&  pos.y + slope*pos.x > -c*slope - HALF_WIDTH; // f(x) = -4/3x - c
			bool cond5 = pos.y < height + HALF_WIDTH &&  pos.y > height - HALF_WIDTH; // f(x) = height
			bool cond6 = pos.y < -height + HALF_WIDTH &&  pos.y > -height - HALF_WIDTH; // f(x) = -height

			if(cond1 || cond2 || cond3 || cond4 || cond5 || cond6)
			{
				gl_FragColor = vec4(1., 1., 1., 1.0);
			}
			else
			{
				gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			}
		}

		void hexagon2()
		{
			vec2 center = vec2(vCx, vCy);
			float HALF_WIDTH = vWidth / 2.0;

			/*
			Représente le coté haut droit de l'hexagon (un quart de l'hexagon)
		 	En jouant avec les valeurs absolus et les signes, on peut faire des symétries
			fFW : flatFunctionWidth
			fFH : flatFunctionHeight
			^
			¦
			¦____fFW___+
			¦				\
			fFH			 \
			¦				  \
			¦--------------+-------->

			vWidth = épaisseur du trait obtenu via le slider coté JS
			*/
			float flatFunctionWidth = sin(radians(30.0)) * vRadius;
			float flatFunctionHeight = cos(radians(30.0)) * vRadius;
			float y = 10.0;

			// px et py: permet de déplacer l'origine de l'hexagone à la position cliquée avec la souris sur le canevas
			float px = pos.x - center.x;
			float py = pos.y - center.y;
			float s = sign(px);

			// Calcule la valeur Y qu'on devrait obtenir
			// Cas 1: ligne horizontale
			if(abs(px) >= 0.0 && abs(px) <= flatFunctionWidth)
			{
				y = line(0.0, px, flatFunctionHeight);
			}
			// Cas 2: ligne de biais
			else if(abs(px) > flatFunctionWidth && abs(px) <= vRadius + HALF_WIDTH)
			{
				// Le signe permet de déterminer si notre x est à gauche ou à droite
				// dans le système de coordonnée et donc de pouvoir définir la position
				// et l'angle de notre segment
				float deltaX = s * (vRadius-flatFunctionWidth);
				y = line((-flatFunctionHeight/deltaX), px - s * vRadius, 0.0);
			}

			// Si la position y calculée correspond à celui du pixel courant
			// on affiche du blanc
			// On prend en compte le largeur du trait avec +- la moitié de la largeur
			if(abs(py) >= y - HALF_WIDTH && abs(py) <= y + HALF_WIDTH)
			{
				gl_FragColor = vec4(1., 1., 1., 1.0);
			}
			else
			{
				gl_FragColor = vec4(0., 0., 0., 1.0);
			}
		}

		void main(void)
		{
			//hexagon1(); // Lucas
			hexagon2(); // Malik
		}
	</script>

	<script>
		var centerX = 0.0;
		var centerY = 0.0;
		var circleRadius = 0.5; // 50%
		var cercleWidth = 0.02;

		var vertexBuffer=null;
		var indexBuffer=null;
		var indices=[];
		var vertices=[];
		var mvMatrix=mat4.create();
		var pMatrix=mat4.create();

		function initShaderParameters(prg)
		{
			prg.vertexPositionAttribute=glContext.getAttribLocation(prg, "aVertexPosition");
			glContext.enableVertexAttribArray(prg.vertexPositionAttribute);

			prg.radiusUniform = glContext.getUniformLocation(prg, "uRadius");
			prg.centerXUniform = glContext.getUniformLocation(prg, "uCx");
			prg.centerYUniform = glContext.getUniformLocation(prg, "uCy");
			prg.cercleWidthUniform = glContext.getUniformLocation(prg, "uWidth");

			prg.pMatrixUniform = glContext.getUniformLocation(prg, "uPMatrix");
			prg.mvMatrixUniform = glContext.getUniformLocation(prg, "uMVMatrix");
		}

		function drawSquares()
		{
			var sceneBegin = -1;
			var squareSize = 2;

			vertices.push(sceneBegin, sceneBegin, 0.0);
			vertices.push(sceneBegin + squareSize, sceneBegin, 0.0);
			vertices.push(sceneBegin, sceneBegin + squareSize, 0.0);
			vertices.push(sceneBegin + squareSize, sceneBegin + squareSize, 0.0);
			indices.push(0, 1, 2, 1, 2, 3);
		}

		function initBuffers()
		{
			drawSquares();
			vertexBuffer = getVertexBufferWithVertices(vertices);
			indexBuffer = getIndexBufferWithIndices(indices);
		}

		function drawScene()
		{
				glContext.clearColor(0.9, 0.9, 0.9, 1.0);
				glContext.enable(glContext.DEPTH_TEST);
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				glContext.viewport(0, 0, c_width, c_height);
				mat4.identity(pMatrix);mat4.identity(mvMatrix);

				glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
				glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

				glContext.uniform1f(prg.radiusUniform, circleRadius);
				glContext.uniform1f(prg.centerXUniform, centerX);
				glContext.uniform1f(prg.centerYUniform, centerY);
				glContext.uniform1f(prg.cercleWidthUniform, cercleWidth);

				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

				glContext.drawElements(glContext.TRIANGLES, indices.length, glContext.UNSIGNED_SHORT, 0);
			}

		function initWebGL()
		{
			glContext=getGLContext('webgl-canvas');
			initProgram();
			initBuffers();
			renderLoop();
		}

		function sliderRadiusChanged()
		{
			circleRadius = document.getElementById("slider1").value / 100.0;

			console.log(this.circleRadius);
		}

		function sliderWidthChanged()
		{
			cercleWidth = document.getElementById("slider2").value / 1000.0;

			console.log(this.cercleWidth);
		}

		</script>

	<body onload="initWebGL()">
		<script>
			displayTitle("WebGL - Labo. 1 : Un hexagone avec un seul carré", 1,1,1,1,1,1,1);
		</script>

		<br>Un hexagone avec un seul carré.

		<br><br>Rayon : <input id="slider1" value="49" min="0" max="100" oninput="sliderRadiusChanged();" type="range">
		<br>Epaisseur : <input id="slider2" value="47" min="0" max="100" oninput="sliderWidthChanged();" type="range">
		<br>Centre : cliquer sur le canevas

		<br><canvas id="webgl-canvas" width="500" height="500">HTML5 is not supported</canvas>


	<script id="code-js" type="text/javascript">
		var myCanvas = document.getElementById('webgl-canvas');
		myCanvas.addEventListener('click', function(evt) {
			var mousePos = getMousePos(myCanvas, evt);
			centerX = (mousePos.x - myCanvas.width/2.0) / myCanvas.width * 2.0;
			centerY = (myCanvas.height/2.0 - mousePos.y) / myCanvas.height * 2.0;
		}, false);
		function getMousePos(myCanvas, evt) {
			var rect = myCanvas.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left,
				y: evt.clientY - rect.top
			};
		}
	</script>

</body></html>
